#+TITLE: Lambda-x86 Project Notes

I've decided to build a quick-and-dirty compiler following _An Incremental Approach to Compiler Construction_ by Abdulaziz Ghuloum. I can build a bigger compiler later.

I've also decided to ditch continuation-passing style for this first draft. I'll get my head around regular recursive implementations first.

I wanted to use stack-based parameter passing, but I gave up and am just using four registers instead. (I've forgotten a bit about how the stack works and I just wanted to move on.)

* Tasks
** TODO Rewrite compiler to not use ~push~ and ~pop~ commands
Turns out there's a new bug with ~let~ that will make using ~push~ and
~pop~ difficult: I'm manually rewriting the stack pointer to get
function calls to work, but that messes up my variable references

** DONE Fix up parser to handle booleans
   CLOSED: [2020-03-26 Thu 22:06]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-03-26 Thu 22:06]
   :END:
** DONE Finish parsing ~let~ nodes
   CLOSED: [2020-03-27 Fri 20:30]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-03-27 Fri 20:30]
   :END:
** DONE Fix (cons (funcall) (any)) bug                                  :bug:
   CLOSED: [2020-04-23 Thu 21:38]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-04-23 Thu 21:38]
   :END:
Trying to run something like this:

#+BEGIN_SRC racket

  (compile (parse '(labels ((f (code (n) (if (= n 0) 1 (* n (app f (- n 1)))))))
                           (cons (app f 5) 6))))

#+END_SRC

Computes the factorial value correctly, but gives something that looks like a pointer for the ~cdr~.

* Tasks for later
** TODO Should I have a ~node/app~ for regular function calls, and a ~node/lapp~ for direct lambda calls?
I think so. It's kind of like differentiating between ~kapp~ and regular ~app~.
** TODO Write a tortue test for the compiler thus far
** TODO Fix up type checker                                     :enhancement:
I wonder if there's a way to use the type information to make my assembler more efficient. (I bet there is; I'll leave that for an enhancement.)
** TODO Use type information to improve instruction choice      :enhancement:
* Resources
** An Incremental Approach to Compiler Construction :ATTACH:
   :PROPERTIES:
   :Attachments: An%20Incremental%20Approach%20to%20Compiler%20Construction.pdf
   :ID:       91BA83F1-5BD6-42B1-BC3F-C3CEE4168023
   :END:
** Seeing what C compiles something to

Write the C code to a file called ~foo.c~; example:

#+BEGIN_SRC c
int main() {
  int foo = 1;
  int bar = 2;
  return foo == bar;
}
#+END_SRC

Then compile with:

#+BEGIN_SRC sh

  gcc -fomit-frame-pointer -S foo.c

#+END_SRC

That should give you a file named =foo.s= that looks like:

#+BEGIN_SRC asm

  	.section	__TEXT,__text,regular,pure_instructions
	.build_version macos, 10, 15	sdk_version 10, 15, 4
	.globl	_main                   ## -- Begin function main
	.p2align	4, 0x90
_main:                                  ## @main
	.cfi_startproc
## %bb.0:
	movl	$0, -4(%rsp)
	movl	$1, -8(%rsp)
	movl	$2, -12(%rsp)
	movl	-8(%rsp), %eax
	cmpl	-12(%rsp), %eax
	sete	%cl
	andb	$1, %cl
	movzbl	%cl, %eax
	retq
	.cfi_endproc
                                        ## -- End function

.subsections_via_symbols

#+END_SRC
* Notebook
** DONE Recursion bug
   CLOSED: [2020-04-03 Fri 00:05]
   :LOGBOOK:
   - State "DONE"       from              [2020-04-03 Fri 00:05]
   :END:

These break:

#+BEGIN_SRC racket
(compile (parse '(labels ((f0 (code (a) (+ a 1))) (f1 (code (b) (if (= b 0) (app f0 b) (app f1 (+ b 1)))))) (app f1 1))))

(compile (parse '(labels ((f0 (code (a) (+ a 1))) (f1 (code (b) (if (= b 0) (app f0 b) (let ((c (+ b 1))) (app f1 c)))))) (app f1 1))))
#+END_SRC

But these don't:

#+BEGIN_SRC racket
(compile (parse '(labels ((f0 (code (a) (+ a 1))) (f1 (code (b) (if (= b 0) (app f0 b) (let ((c (+ b 1))) (+ c 1)))))) (app f1 1))))

(compile (parse '(labels ((f0 (code (a) (+ a 1))) (f1 (code (b) (if (= b 0) (app f0 b) (app f0 7))))) (app f1 1))))

(compile (parse '(labels ((f0 (code (a) (+ a 1)))) (let ((a 1)) (app f0 (+ a 1))))))
#+END_SRC

Oh, oops. That's because the breaking ones are actually recursing infinitely.
** Multi-value recursion bug

This works:

#+BEGIN_SRC racket

  (compile (parse '(labels ((factorial (code (n) (if (= n 0) 1 (* n (app factorial (- n 1))))))) (app factorial 5))))

#+END_SRC

But this doesn't:

#+BEGIN_SRC racket

  (compile (parse '(labels ((factorial (code (n acc) (if (= n 0) acc (app factorial (- n 1) (* acc n)))))) (app factorial 5 1))))

#+END_SRC

I think it's because I'm not using my stack right: instead of writing values to absolute places on the stack, I should try to use push and pop. Else, check my useage of the stack. See page 276 in the textbook for a detailed description.
